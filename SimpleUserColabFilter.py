# -*- coding: utf-8 -*-
"""UserColabFilter.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OntFdOLi4UBtAmNY7IrTtsZ8uGplZDkk
"""

import pandas as pd
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity

# Data table example: (User-Item Matrix)
data = {
    "Product A": [5, 4, np.nan, 3, 5],
    "Product B": [4, np.nan, 5, 3, np.nan],
    "Product C": [np.nan, 5, 4, 2, 3],
    "Product D": [3, 2, 3, np.nan, 4],
    "Product E": [np.nan, 1, np.nan, 5, 2],
}
df = pd.DataFrame(data, index=["U1", "U2", "U3", "U4", "U5"])

# Show table
df

# Calculate similarity
similarity_matrix = cosine_similarity(df.fillna(0))  # Điền NaN bằng 0 để tính toán
similarity_df = pd.DataFrame(similarity_matrix, index=df.index, columns=df.index)

# Show users' similarity table
similarity_df

# Prediction function
def predict_ratings(user, product):
    if not np.isnan(df.loc[user, product]):
        return df.loc[user, product]  # if already rated

    # Find users rated this product
    rated_users = df[product].dropna().index

    # Filter out the similarities of current users with those who have reviewed the product
    similarities = similarity_df.loc[user, rated_users]

    # Get ratings from users who have rated the product
    ratings = df.loc[rated_users, product]

    # Calculate prediction rating by taking weighted average by similarity
    weighted_sum = np.dot(similarities, ratings)
    sum_of_weights = similarities.sum()

    return weighted_sum / sum_of_weights if sum_of_weights > 0 else np.nan

# Try predict U1's rating for Product C
predicted_rating = predict_ratings("U1", "Product C")
predicted_rating

from sklearn.metrics import mean_squared_error, mean_absolute_error

actual_ratings = [3, 4, 5]  # Actual rating to compare with predicted ratings
predicted_ratings = [predict_ratings("U1", "Product C"), predict_ratings("U2", "Product B"), predict_ratings("U3", "Product A")]

rmse = np.sqrt(mean_squared_error(actual_ratings, predicted_ratings))
mae = mean_absolute_error(actual_ratings, predicted_ratings)

print(f"RMSE: {rmse:.4f}")
print(f"MAE: {mae:.4f}")